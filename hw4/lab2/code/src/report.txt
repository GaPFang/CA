1. Adder
Adder module is a combinational module, it reads two 32-bit inputs, add them, and then output the result. Because the add operation is a built-in operation in Verilog, I can directly use it.
2. ALU
ALU module is a combinational module, it first reads ALU control signal, and two 32-bit input, then compute them and output the 32-bit arithmetic result. This module can do seven kinds of operations, depending on the ALU control signal received, including AND, XOR, left shift, add, minus, multiply, and arithmetic right shift. Because these operators are implemented by Verilog already, I can apply them without implementing these operations myself. After finishing the operation, the module will output the result.
3. ALU_Control
ALU Control is a combinational module, it first reads the 2-bit ALUOp signal from the Control unit, and 3-bit func3 and 7-but func7, respectively, and then output the 3-bit ALU control signal which will be used to control the ALU. By these inputs, ALU Control module can know which type the instruction is, and then output the corresponding ALU control signal. Because there are only seven instructions to be implemented, I directly use exhaustive method, instead of K-Map.
4. Control
Control module is a combinational module, it reads a 7-bit opcode from the instruction, and then output seven signals which will be used to control different units. Among the seven instructions, there are only two kinds of opcodes, so I only need to list the seven signals of the two cases.
5. CPU
CPU module is a sequential module, it reads clock signal and reset bit as input. There are many sub-modules within the CPU module connecting with wires used to transfer bits.
First, Data_Memory outputs instruction based on pc_o from PC, then store in IFID latch. Then, the instruction will be sent to Registers module to read the data from register ,to Control module to decode the instruction and output seven control signals, to Sign_Extend module to extend the immediate value. and to Flush module to check if the pc should branch, then store datas and signals in IDEX latch to store the data . Then, the data will be sent to ALU module to compute the data, and then store the data in EXMEM latch. Then, the data will be sent to Data_Memory module to read or write data from memory, and then store the data in MEMWB latch. Finally, the data will be sent to Registers module to write data to register.
6. Flush
Flush consists of a comparer and an AND gate. It reads two RS data, and a Branch signal. If the two RS datas are the same, and the Branch signal is 1, then the AND gate will output 1, and Flush module will set Flush signal to 1, which will be sent to IF/ID latch to flush the instruction and set pc_i to pc_branch_i.
7. Forwarding
Forwarding module is a combinational module, it reads two 5-bit RS data from IDEX latch, and two 5-bit RD data from EXMEM and MEMWB latch, and two RegWrite signal from EXMEM and MEMWB latch, and then output two 2-bit signals A and B. A and B will be used to control the MUX in ALU module. If EXMEM.RD and IDEX.RS1 or IDEX.RS2 are the same, and EXMEM.RegWrite is 1, then A or B will be 10, which means the data from EXMEM will be forwarded to EX. If MEMWB.RD and IDEX.RS1 or IDEX.RS2 are the same, and MEMWB.RegWrite is 1, and do not need to forward from EXMEM, then A or B will be 01, which means the data from MEMWB will be forwarded to EX. If there is no need to forward, then A and B will be 00.
8. Hazard_Detection
Hazard_Detection module is a combinational module, it reads RS1addr and RS2addr from IFID latch, RDaddr and MemRead signal from IDEX latch, and then output two signals, Stall_o and NoOp. If MemRead is 1, and RS1addr or RS2addr is the same as RDaddr, then Stall_o and NoOp will be 1, which means the instruction in the IFID latch will stall and do nothing and Control signal will set all the signal to false. If there is no need to stall, then Stall_o and NoOp will be 0.
9. Latch
There are four pipeline latch in total, which store the data from the previous stage and send them to the next stage. IF/ID latch stores the instruction fetched from Data_Memory module. ID/EX latch stores the data from register, Control module, and IF/ID latch. EX/MEM latch stores the data from ALU and ID/EX latch. MEM/WB latch stores the data from memory and EX/MEM latch.
10. MUX
MUX1 is combinational module, it reads a control signal (in this case, ALUSrc signal), and two 32-bit inputs a and b, if the signal is 0, output a (in this case, RS2), if the signal is 1, output b (in this case, immed). In this case, the output will be sent to ALU as an operand.
MUX2 is combinational module, it reasd a control signal (in this case, ALUSrc signal), and four 32-bit inputs a, b, c, and d, it outputs a, b, c or d if the signal is 00, 01, 10 or 11, respectively.
11. Sign_Extend
Sign Extend module is a combinational module, it reads a 12-bit input, and then check if in[11] is 0 or 1. If in[11] is 0 (positive), output the result with twenty 0s before the input, and if in[11] is 1 (negative), output the result with twenty 1s before the input.